/*
*  Ray Tracer kernel
**/
namespace kernel{

    const height = 600;
    const width = 800;
    const RAW_MEMORY = new SharedArrayBuffer(height*width*4 + 65536);
    ll.Runtime.init(RAW_MEMORY, 0, RAW_MEMORY.byteLength, true);

    const shadows = true;		// Compute object shadows
    const reflection = true;	// Compute object reflections
    const reflection_depth = 2;
    const antialias = false; // true;		// Antialias the image (expensive but pretty)

    const debug = false;		// Progress printout, may confuse the consumer

    const SENTINEL = 1e32;
    const EPS = 0.00001;

    function DL2(x, y) { return {x:x, y:y}; }
    function DL3(x, y, z) { return {x:x, y:y, z:z}; }
    function DL4(x, y, z, w) { return {x:x, y:y, z:z, w:w}; }
    function F3(a, b, c) { return {a:a, b:b, c:c}; }
    function RGB(r, g, b) { return {r:r, g:g, b:b}; }

    let black = DL3(0,0,0);

    function add(a, b) { return DL3(a.x+b.x, a.y+b.y, a.z+b.z); }
    function addi(a, c) { return DL3(a.x+c, a.y+c, a.z+c); }
    function sub(a, b) { return DL3(a.x-b.x, a.y-b.y, a.z-b.z); }
    function subi(a, c) { return DL3(a.x-c, a.y-c, a.z-c); }
    function muli(a, c) { return DL3(a.x*c, a.y*c, a.z*c); }
    function divi(a, c) { return DL3(a.x/c, a.y/c, a.z/c); }
    function neg(a) { return DL3(-a.x, -a.y, -a.z); }
    function length(a) { return Math.sqrt(a.x*a.x + a.y*a.y + a.z*a.z); }
    function normalize(a) { var d = length(a); return DL3(a.x/d, a.y/d, a.z/d); }
    function cross(a, b) { return DL3(a.y*b.z - a.z*b.y, a.z*b.x - a.x*b.z, a.x*b.y - a.y*b.x); }
    function dot(a, b) { return a.x*b.x + a.y*b.y + a.z*b.z; }
    function fract(f) { return f - Math.floor(f); }
    function fract_add1(f) {
        let f1 = f - Math.floor(f);
        return f1 - Math.floor(f1 + 1);
    }
    function clampInt(x:number, lo:number, hi:number):number {
        if (x < lo) {return lo;}
        if (x > hi) {return hi;}
        return x;
    }

    @turbo:: struct Vector2 {
        x: float32
        y: float32

        @get(SELF){
            return DL2(SELF.x, SELF.y);
        }
    } @end

    @turbo:: struct Vector3 {
        x: float32
        y: float32
        z: float32

        @get(SELF){
            return DL3(SELF.x, SELF.y, SELF.z);
        }
    } @end

    @turbo:: struct Face3 {
        a: int32
        b: int32
        c: int32

        @get(SELF){
            return F3(SELF.a, SELF.b, SELF.c);
        }
    } @end

    @turbo:: struct Box {
        min:Vector3
        max:Vector3
    } @end

    // Avoid intermediate DL3 objects

    function subvref(a, b) { return DL3(a.x-Vector3.x(b), a.y-Vector3.y(b), a.z-Vector3.z(b)); }
    function subrefref(a, b) { return DL3(Vector3.x(a)-Vector3.x(b), Vector3.y(a)-Vector3.y(b), Vector3.z(a)-Vector3.z(b)); }
    function mulrefi(a, c) { return DL3(Vector3.x(a)*c, Vector3.y(a)*c, Vector3.z(a)*c); }

    /* Texture Domain */

    @turbo:: class Color {
        r: float32
        g: float32
        b: float32

        @method init(SELF, color){
            SELF.r = color.r;
            SELF.g = color.g;
            SELF.b = color.b;
            return SELF;
        }

        @method Color.fromJson = function(SELF, color) {
            if (color) {
                return Color.init(SELF, color);
            } else {
                return null;
            }
        };

        @method Color.hexColor = function(SELF, hex:number):number {
            var red = ((hex >> 16) & 255 ) / 255;
            var green = ((hex >> 8) & 255) / 255;
            var blue = (hex & 255) / 255;
            return Color.pow(Color.init(SELF, RGB(red, green, blue)), 2.2);
        };

        @method Color.newColor = function(SELF, c:RGBA):number {
            return Color.init(SELF, RGB(c.r / 65535, c.g / 65535, c.b / 65535));
        };

        @method Color.RGBA = function(SELF:number):RGBA {
            let _c:Uint8Array = new Uint8Array(3);
            _c[0] = Math.max(0, Math.min(255, Color.r(SELF) * 255));
            _c[1] = Math.max(0, Math.min(255, Color.g(SELF) * 255));
            _c[2] = Math.max(0, Math.min(255, Color.b(SELF) * 255));
            return {r: _c[0], g: _c[1], b: _c[2], a: 255};
        };

        @method Color.isBlack = function(SELF:number):boolean {
            return Color.r(SELF) === 0 && Color.g(SELF) === 0 && Color.b(SELF) === 0;
        };

        @method Color.isWhite = function(SELF:number):boolean {
            return Color.r(SELF) === 1 && Color.g(SELF) === 1 && Color.b(SELF) === 1;
        };

        Color.add = function(a:Color, b:Color){return RGB(a.r + b.r, a.g + b.g, a.b + b.b);};
        @method Color.add_mem = function(a:number, b:number){
            return RGB(Color.r(a) + Color.r(b), Color.g(a) + Color.g(b), Color.b(a) + Color.b(b));
        };

        Color.sub = function(a:Color, b:Color){return RGB(a.r - b.r, a.g - b.g, a.b - b.b);};
        @method Color.sub_mem = function(a:number, b:number){
            return RGB(Color.r(a) - Color.r(b), Color.g(a) - Color.g(b), Color.b(a) - Color.b(b));
        };

        Color.mul = function(a:Color, b:Color){return RGB(a.r * b.r, a.g * b.g, a.b * b.b);};
        @method Color.mul_mem = function(a:number, b:number) {
            return RGB(Color.r(a) * Color.r(b), Color.g(a) * Color.g(b), Color.b(a) * Color.b(b));
        };

        Color.mulScalar = function(a:Color, f:number){return RGB(a.r * f, a.g * f, a.b * f);};
        @method Color.mulScalar_mem = function(a:number, f:number) {
            return RGB(Color.r(a) * f, Color.g(a) * f, Color.b(a) * f);
        };

        Color.divScalar = function(a:Color, f:number){return RGB(a.r / f, a.g / f, a.b / f);};
        @method Color.divScalar_mem = function(a:number, f:number) {
            return RGB(Color.r(a) / f, Color.g(a) / f, Color.b(a) / f);
        };

        Color.min = function(a:Color, b:Color) {return RGB( Math.min(a.r , b.r), Math.min(a.g , b.g), Math.min(a.b , b.b) );};
        @method Color.min_mem = function(a:number, b:number) {
            return RGB( Math.min(Color.r(a) , Color.r(b)), Math.min(Color.g(a) , Color.g(b)), Math.min(Color.b(a) , Color.b(b)) );
        };

        Color.max = function(a:Color, b:Color){return RGB( Math.max(a.r , b.r), Math.max(a.g , b.g), Math.max(a.b , b.b) );};
        @method Color.max_mem = function(a:number, b:number){
            return RGB( Math.max(Color.r(a) , Color.r(b)), Math.max(Color.g(a) , Color.g(b)), Math.max(Color.b(a) , Color.b(b)) );
        };

        Color.pow = function(a:Color, f:number) {return RGB( Math.pow(a.r, f), Math.pow(a.g, f), Math.pow(a.b, f) );};
        @method Color.pow_mem = function(a:number, f:number) {
            return RGB( Math.pow(Color.r(a), f), Math.pow(Color.g(a), f), Math.pow(Color.b(a), f) );
        };

        Color.mix = function(a:Color, b:Color, pct:number) {
            let _a = Color.mulScalar(a, 1 - pct);
            let _b = Color.mulScalar(b, pct);
            return RGB(_a.r + _b.r, _a.g + _b.g, _a.b + _b.b);
        };
        @method Color.mix_mem = function(a:number, b:number, pct:number) {
            let _a = Color.mulScalar_mem(a, 1 - pct);
            let _b = Color.mulScalar_mem(b, pct);
            return RGB(_a.r + _b.r, _a.g + _b.g, _a.b + _b.b);
        };

        @method set(SELF, r:number, g:number, b:number) {
            SELF.r = r;
            SELF.g = g;
            SELF.b = b;
            return SELF;
        }

        @method clone(SELF):number {
            return Color.init(SELF, RGB(SELF.r, SELF.g, SELF.b));
        }

        Color.brightColors = [
            Color.hexColor(0xFF00FF),
            Color.hexColor(0x84FF00),
            Color.hexColor(0xFF0084),
            Color.hexColor(0x00FFFF),
            Color.hexColor(0x00FF84),
            Color.hexColor(0xDD40FF),
            Color.hexColor(0xFFFF00)
        ];

        Color.random = function():Color {
            return new Color(Math.random(), Math.random(), Math.random());
        };

        Color.randomBrightColor = function():Color {
            var i:number = Math.round(Math.random() * Color.brightColors.length);
            return Color.brightColors[i];
        };

    } @end

    @turbo:: class Texture {
        data: Color.Array
        height: int32
        width: int32



        @method init(SELF, height, width, color) {
            SELF.height = height;
            SELF.width = width;
            var data = @new Color.Array(height * width);
            //var c = (255<<24)|((255*color.z)<<16)|((255*color.y)<<8)|(255*color.x)

            if(!color){
                color = black;
            }

            if(color instanceof Float32Array){
                for ( var i=0, l=width*height ; i < l ; i += 3) {
                    Color.Array.setAt(data, i, Color.init( RGB(color[i], color[i+1], color[i+2]) ) );
                }
            }else{
                for ( var i=0, l=width*height ; i < l ; i++ ) {
                    Color.Array.setAt(data, i, Color.init(color));
                }
            }

            SELF.data = data;
            return SELF;
        }

        // For debugging only
        @method ref(SELF, y, x) {
            return Color.Array.at(SELF.data, (SELF.height-y)*SELF.width+x);
        }

        //
        @method bilinearSample(SELF, u:number, v:number):Color {
            let _w = SELF.width;
            let w = _w - 1;
            let h = SELF.height - 1;
            let f = u * w;
            let X = Math.floor(f);
            let x = f - X;
            f = v * h;
            let Y = Math.floor(f);
            let y = f - Y;

            let x0 = X;
            let y0 = Y;
            let x1 = x0 + 1;
            let y1 = y0 + 1;
            let i00:number = y0 * _w + x0;
            let i01:number = y1 * _w + x0;
            let i10:number = y0 * _w + x1;
            let i11:number = y1 * _w + x1;

            let len:number = SELF.data.length;

            i00 = i00 >= len ? len - 1 : i00;
            i01 = i01 >= len ? len - 1 : i01;
            i10 = i10 >= len ? len - 1 : i10;
            i11 = i11 >= len ? len - 1 : i11;

            let c00 = Color.Array.at(SELF.data, i00);
            let c01 = Color.Array.at(SELF.data, i01);
            let c10 = Color.Array.at(SELF.data, i10);
            let c11 = Color.Array.at(SELF.data, i11);
            let c = RGB();
            c = Color.add(c, Color.mulScalar_mem(c00, (1 - x) * (1 - y)));
            c = Color.add(c, Color.mulScalar_mem(c10, x * (1 - y)));
            c = Color.add(c, Color.mulScalar_mem(c01, (1 - x) * y));
            c = Color.add(c, Color.mulScalar_mem(c11, x * y));

            //if (c.isBlack()) {
                //console.log(c00, c01, c10, c11);
            //}

            return c;
        }

        @method sample(SELF, u:number, v:number):Vector3 {
            // u = fract(fract(u) + 1);
            u = fract_add1(u);
            // v = fract(fract(v) + 1);
            v = fract_add1(v);
            return SELF.bilinearSample(u, 1 - v);
        }
        @method normalSample(SELF, u:number, v:number):Vector3 {
            let c = SELF.sample(u, v);
            return normalize(RGB(c.x * 2 - 1, c.y * 2 - 1, c.z * 2 - 1));
        }

        @method bumpSample(SELF, u:number, v:number):Vector3 {
            u = fract_add1(u);
            v = fract_add1(v);
            v = 1 - v;
            let w = SELF.width;
            let h = SELF.height;
            let x:number = Math.round(u * w);
            let y:number = Math.round(v * h);
            let x1:number = clampInt(x - 1, 0, w - 1);
            let x2:number = clampInt(x + 1, 0, w - 1);
            let y1:number = clampInt(y - 1, 0, h - 1);
            let y2:number = clampInt(y + 1, 0, h - 1);
            let cx = Color.sub_mem(Color.Array.at(SELF.data, y * w + x1), Color.Array.at(SELF.data, y * w + x2));
            let cy = Color.sub_mem(Color.Array.at(SELF.data, y1 * w + x), Color.Array.at(SELF.data, y2 * w + x));
            return RGB(cx.x, cy.x, 0);
        }
        // Not a hot function
        @method setColor(SELF, y, x, v) {
            int32.Array.setAt(SELF.data, (SELF.height-y-1)*SELF.width+x, (255<<24)|((255*v.z)<<16)|((255*v.y)<<8)|(255*v.x));
        }
    } @end

    @turbo:: struct Material {
        diffuse:   Vector3
        specular:  Vector3
        shininess: float64
        ambient:   Vector3
        mirror:    float64
    } @end

    function makeMaterial(diffuse, specular, shininess, ambient, mirror) {
        var v = new Material;
        v.diffuse = diffuse;
        v.specular = specular;
        v.shininess = shininess;
        v.ambient = ambient;
        v.mirror = mirror;
        return v;
    }

    @turbo:: class Surface {
        material: Material

        @method init(SELF, material) {
            SELF.material = material;
            return SELF;
        }

        @virtual intersect(SELF, eye, ray, min, max) {
            throw "Pure: Surface.intersect"
        }

        @virtual normal(SELF, p) {
            throw "Pure: Surface.normal"
        }
    } @end

    @turbo:: class Triangle extends Surface {
        v1: Vector3
        v2: Vector3
        v3: Vector3

        n1: Vector3
        n2: Vector3
        n3: Vector3

        t1: Vector3
        t2: Vector3
        t3: Vector3

        @method init(SELF, material, v1, v2, v3) {
            Surface.init(SELF, material)
            SELF.v1 = v1;
            SELF.v2 = v2;
            SELF.v3 = v3;
            return SELF;
        }

        @virtual intersect(SELF, eye, ray, min, max) {
            // TODO: observe that values that do not depend on g, h, and i can be precomputed
            // and stored with the triangle (for a given eye position), at some (possibly significant)
            // space cost.  Notably the numerator of "t" is invariant, as are many factors of the
            // numerator of "gamma".
            var a = SELF.v1.x - SELF.v2.x;
            var b = SELF.v1.y - SELF.v2.y;
            var c = SELF.v1.z - SELF.v2.z;
            var d = SELF.v1.x - SELF.v3.x;
            var e = SELF.v1.y - SELF.v3.y;
            var f = SELF.v1.z - SELF.v3.z;
            var g = ray.x;
            var h = ray.y;
            var i = ray.z;
            var j = SELF.v1.x - eye.x;
            var k = SELF.v1.y - eye.y;
            var l = SELF.v1.z - eye.z;
            var M = a*(e*i - h*f) + b*(g*f - d*i) + c*(d*h - e*g);
            var t = -((f*(a*k - j*b) + e*(j*c - a*l) + d*(b*l - k*c))/M);
            if (t < min || t > max)
                return {obj:NULL,dist:0};
            var gamma = (i*(a*k - j*b) + h*(j*c - a*l) + g*(b*l - k*c))/M;
            if (gamma < 0 || gamma > 1.0)
                return {obj:NULL,dist:0};
            var beta = (j*(e*i - h*f) + k*(g*f - d*i) + l*(d*h - e*g))/M;
            if (beta < 0.0 || beta > 1.0 - gamma)
                return {obj:NULL,dist:0};
            return {obj:SELF, dist:t};
        }

        @virtual normal(SELF, p) {
            // TODO: Observe that the normal is invariant and can be stored with the triangle
            return normalize(cross(subrefref(SELF.v2.ref, SELF.v1.ref), subrefref(SELF.v3.ref, SELF.v1.ref)));
        }

    } @end
    /* Primitives End */

    @turbo:: class Object3D {
        children:Object3D.Array

    } @end

    @turbo:: class BufferGeometry {
        points: Vector3.Array
        normals: Vector3.Array
        texCoords: Vector2.Array
        indices: Face3.Array
    } @end
    
    @turbo:: class Mesh extends Object3D{
        geometry:BufferGeometry

    } @end

    @turbo:: class Scene extends Surface {
        length: int32
        objects: Surface.Array

        @method init(SELF, objects) {
            var len = objects.length;
            SELF.length = len;
            var objs = @new Surface.Array(len);
            for ( var i=0 ; i < len ; i++ )
                Surface.Array.setAt(objs, i, objects[i]);
            SELF.objects = objs;
            return SELF;
        }

        @virtual intersect(SELF, eye, ray, min, max) {
            var min_obj = ll.Runtime.NULL;
            var min_dist = SENTINEL;

            var objs = SELF.objects;
            for ( var idx=0, limit=SELF.length ; idx < limit ; idx++ ) {
                var surf = Surface.Array.at(objs, idx);
                var tmp = Surface.intersect(surf, eye, ray, min, max);
                var obj = tmp.obj;
                var dist = tmp.dist;
                if (obj)
                    if (dist >= min && dist < max)
                        if (dist < min_dist) {
                            min_obj = obj;
                            min_dist = dist;
                        }
            }
            return {obj:min_obj, dist:min_dist};
        }

    } @end

}
    
    